# -*- coding: utf-8 -*-
"""Emergency Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jNhq9oIw0wa8bw4HDBZjkkS-CNhBCRPO
"""

# pip install numpy pandas matplotlib  # install these via your environment, not inline

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- Building Evacuation Scenario (4 Floors) ---
floors = 4
rooms_per_floor = 5
total_rooms = floors * rooms_per_floor

np.random.seed(42)  # for reproducibility

# Base distances (meters) to nearest exits
distances = np.random.uniform(5, 50, total_rooms)

# Base data table
data = pd.DataFrame({
    "Floor": np.repeat(np.arange(1, floors + 1), rooms_per_floor),
    "Room": np.arange(1, total_rooms + 1),
    "Distance": distances
})

print("ðŸ¢ Building Structure:")
print(data)

def ahp_weights(criteria_matrix):
    eigvals, eigvecs = np.linalg.eig(criteria_matrix)
    max_index = np.argmax(eigvals)
    weights = np.real(eigvecs[:, max_index])
    weights = weights / np.sum(weights)
    return np.real(weights)

def fitness_function(solution, weights):
    # Lower risk and shorter distance = higher fitness
    risk_score = np.sum(solution[:, 0] * weights[0])
    distance_score = np.sum(solution[:, 1] * weights[1])
    return 1 / (risk_score + distance_score)

def artificial_bee_colony(data, weights, colony_size=20, max_iter=50, limit=10):
    num_food_sources = len(data)
    solutions = np.random.rand(colony_size, num_food_sources, 2)
    fitness = np.array([fitness_function(data.values * s, weights) for s in solutions])
    trial = np.zeros(colony_size)

    best_solution = solutions[np.argmax(fitness)]
    best_fitness = np.max(fitness)

    for iteration in range(max_iter):
        for i in range(colony_size):
            k = np.random.randint(0, colony_size)
            while k == i:
                k = np.random.randint(0, colony_size)
            phi = np.random.uniform(-1, 1, size=solutions[i].shape)
            new_solution = solutions[i] + phi * (solutions[i] - solutions[k])
            new_solution = np.clip(new_solution, 0, 1)

            new_fitness = fitness_function(data.values * new_solution, weights)
            if new_fitness > fitness[i]:
                solutions[i] = new_solution
                fitness[i] = new_fitness
                trial[i] = 0
            else:
                trial[i] += 1

        # Onlooker phase
        prob = fitness / np.sum(fitness)
        for i in range(colony_size):
            if np.random.rand() < prob[i]:
                k = np.random.randint(0, colony_size)
                phi = np.random.uniform(-1, 1, size=solutions[i].shape)
                new_solution = solutions[i] + phi * (solutions[i] - solutions[k])
                new_solution = np.clip(new_solution, 0, 1)

                new_fitness = fitness_function(data.values * new_solution, weights)
                if new_fitness > fitness[i]:
                    solutions[i] = new_solution
                    fitness[i] = new_fitness
                    trial[i] = 0
                else:
                    trial[i] += 1

        # Scout phase
        for i in range(colony_size):
            if trial[i] > limit:
                solutions[i] = np.random.rand(num_food_sources, 2)
                fitness[i] = fitness_function(data.values * solutions[i], weights)
                trial[i] = 0

        current_best = np.max(fitness)
        if current_best > best_fitness:
            best_fitness = current_best
            best_solution = solutions[np.argmax(fitness)]

        if iteration % 10 == 0:
            print(f"Iteration {iteration}: Best Fitness = {best_fitness:.4f}")

    return best_solution, best_fitness

# ðŸ”¥ FIRE SCENARIO
# Fire spreads faster in lower floors and near exits â€” higher risk in those areas
fire_risk = np.linspace(1.0, 0.5, total_rooms) + np.random.uniform(-0.1, 0.1, total_rooms)
fire_risk = np.clip(fire_risk, 0.3, 1.0)

fire_data = data.copy()
fire_data["Risk"] = fire_risk

# AHP: Fire â€” Risk more important than distance (4:1)
fire_matrix = np.array([[1, 4], [1/4, 1]])
fire_weights = ahp_weights(fire_matrix)

print("\nðŸ”¥ FIRE Scenario AHP Weights (Risk, Distance):", fire_weights)
print(fire_data.head())

# ðŸŒŽ EARTHQUAKE SCENARIO
# Higher risk for upper floors (structural instability)
earthquake_risk = np.repeat(np.linspace(0.5, 1.0, floors), rooms_per_floor)
earthquake_risk += np.random.uniform(-0.05, 0.05, total_rooms)
earthquake_risk = np.clip(earthquake_risk, 0.3, 1.0)

earthquake_data = data.copy()
earthquake_data["Risk"] = earthquake_risk

# AHP: Earthquake â€” Distance more important than risk (1:3)
earthquake_matrix = np.array([[1, 1/3], [3, 1]])
earthquake_weights = ahp_weights(earthquake_matrix)

print("\nðŸŒŽ EARTHQUAKE Scenario AHP Weights (Risk, Distance):", earthquake_weights)
print(earthquake_data.head())

# Fire Scenario Optimization
print("\nðŸš¨ Running ABC for FIRE evacuation...")
fire_best_solution, fire_best_fitness = artificial_bee_colony(fire_data[["Risk", "Distance"]], fire_weights)
print("\nðŸ”¥ Best Fire Evacuation Plan Fitness:", fire_best_fitness)

# Earthquake Scenario Optimization
print("\nðŸŒŽ Running ABC for EARTHQUAKE evacuation...")
eq_best_solution, eq_best_fitness = artificial_bee_colony(earthquake_data[["Risk", "Distance"]], earthquake_weights)
print("\nðŸŒŽ Best Earthquake Evacuation Plan Fitness:", eq_best_fitness)

import matplotlib.pyplot as plt
import numpy as np

# Example room names (you can modify this for your actual building)
room_labels = [
    "Room 101", "Room 102", "Room 103", "Room 104",  # 1st Floor
    "Room 201", "Room 202", "Room 203", "Room 204",  # 2nd Floor
    "Room 301", "Room 302", "Room 303", "Room 304",  # 3rd Floor
    "Room 401", "Room 402", "Room 403", "Room 404"   # 4th Floor
]

# Make sure the length matches your best_solution data
num_rooms = len(room_labels)
x = np.arange(num_rooms)

plt.figure(figsize=(12,6))
plt.plot(x, np.mean(fire_best_solution, axis=1)[:num_rooms],
         label='ðŸ”¥ Fire Evacuation Route', color='red', linewidth=2)
plt.plot(x, np.mean(eq_best_solution, axis=1)[:num_rooms],
         label='ðŸŒŽ Earthquake Evacuation Route', color='blue', linewidth=2, linestyle='--')

plt.title("Alternative Evacuation Routes per Room (ABC + AHP)", fontsize=14)
plt.xlabel("Room Number", fontsize=12)
plt.ylabel("Evacuation Priority Score", fontsize=12)
plt.xticks(x, room_labels, rotation=45, ha='right')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

fire_output = fire_data.copy()
fire_output["Evacuation_Priority"] = np.mean(fire_best_solution, axis=1)

eq_output = earthquake_data.copy()
eq_output["Evacuation_Priority"] = np.mean(eq_best_solution, axis=1)

fire_output.to_csv("Fire_Evacuation_Route.csv", index=False)
eq_output.to_csv("Earthquake_Evacuation_Route.csv", index=False)

print("âœ… Results saved as Fire_Evacuation_Route.csv and Earthquake_Evacuation_Route.csv")
